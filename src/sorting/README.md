## Sort Algorithms

[<h3 id="bubble">Bubble</h3>](./bubble_sort.rs)

![alt text][bubble_image]

**Сортировка пузырьком**, или **сортировка обменами** - простой алгоритм сортировки. Соседние элементы массива попарно сравниваются, и если элемент с меньшим индексом больше элемента с большим индексом (больший элемент левее), то они меняются местами. И так до тех пор, пока весь массив не будет отсортирован.

Алгоритм считается учебным и практически не применяется вне учебной литературы, вместо него на практике применяются более эффективные алгоритмы сортировки. В то же время метод сортировки пузырьком лежит в основе некоторых более совершенных алгоритмов, таких как [шейкерная сортировка](#cocktail_shaker), ~~[пирамидальная сортировка]()~~ и ~~[быстрая сортировка]()~~.

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n)
* Средняя скорость O(n^2)

__Memory__
* O(1)

* * *

[<h3 id="cocktail_shaker">Cocktail-Shaker</h3>](./cocktail_shaker_sort.rs)

![alt text][cocktail_shaker_image]

**Шейкерная сортировка** или **сортировка перемешиванием** - разновидность [пузырьковой сортировки](#bubble). Алгоритм расширяет пузырьковую сортировку, работая в двух направлениях.

Хотя он улучшает пузырьковую сортировку за счет более быстрого перемещения элементов в начало списка, он обеспечивает лишь незначительные улучшения производительности.

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n)
* Средняя скорость O(n^2)

__Memory__
* O(1)

* * *

[<h3 id="comb-sort">Comb-sort</h3>](./comb_sort.rs)

![alt text][comb_image]

Основная идея **сортировки расчёской** в том, чтобы первоначально брать достаточно большое расстояние между сравниваемыми элементами и по мере упорядочивания массива сужать это расстояние вплоть до минимального. Таким образом, мы как бы причёсываем массив, постепенно разглаживая на всё более аккуратные пряди. Первоначальный разрыв между сравниваемыми элементами лучше брать с учётом специальной величины, называемой `фактором уменьшения`, оптимальное значение которой равно примерно **1,247**. Сначала расстояние между элементами максимально, то есть равно размеру массива минус один. Затем, пройдя массив с этим шагом, необходимо поделить шаг на фактор уменьшения и пройти по списку вновь. Так продолжается до тех пор, пока разность индексов не достигнет единицы. В этом случае сравниваются соседние элементы как и в сортировке пузырьком, но такая итерация одна.

Оптимальное значение фактора уменьшения 1/(1-e^(-Φ)), где e - основание натурального логарифма, а Φ — золотое сечение. (_Интерсно, почему так..._)

Основная идея — устранить _черепах_, или маленькие значения в конце списка, которые крайне замедляют сортировку пузырьком (_кролики_, большие значения в начале списка, не представляют проблемы для сортировки пузырьком).

В [сортировке пузырьком](#bubble), когда сравниваются два элемента, промежуток (расстояние друг от друга) равен 1. Основная идея сортировки расчёской в том, что этот промежуток может быть гораздо больше, чем единица (~~[сортировка Шелла]()~~ также основана на этой идее, но она является модификацией [сортировки вставками](#insertion-sort), а не [сортировки пузырьком](#bubble)).

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n log n)
* Средняя скорость O(n^2/2^p)

где `p` — число приращений (_я так понимаю, это просто количество произведенных делений, но все равно не очень понимаю среднюю и лучшую скорость_)

__Memory__
* O(1)

> **PS:** я не очень понимаю, в каком случае проверка `gap (шага)` на число меньшее 1 используется до сортировки. Перескочить 1 оно не может сразу на 0, а в википедии указано, что алгоритм пройдется по массиву с шагом 1 всего один раз. Везде эту проверку выносят перед сортировкой, но я буду использовать свой вариант, пока я не пойму, почему все делают иначе, ведь алгоритм работает в обоих случаях.
>> **PPS:** проверка до сортировки нужна в случае пустого массива или массива из 1 элемента.


* * *

[<h3 id="counting-sort">Counting-sort</h3>](./counting_sort.rs)

![alt text][counting_image]

**Сортировка подсчётом** — алгоритм сортировки, в котором используется диапазон чисел сортируемого массива для подсчёта совпадающих элементов. Применение сортировки подсчётом целесообразно лишь тогда, когда сортируемые числа имеют (или их можно отобразить в) диапазон возможных значений, который достаточно мал по сравнению с сортируемым множеством, например, миллион натуральных чисел меньших 1000.

Суть алгоритма - создать вспомогательный массив из 0, размер которого равен максимальному возможному значению в исходном массиве. Затем нужно пройтись по исходному массиву и посчитать количество каждого значения, используя вспомогательный массив. Затем достаточно пройтись по вспомогательному массиву и записать в результирующий массив все значения по порядку.

__Time complexity__
* Худшая скорость O(n+k)
* Лучшая скорость O(n+k)
* Средняя скорость O(n+k)

где `k` - разница между максимальным и минимальным значением в массиве.

__Memory__
* O(n)

* * *

[<h3 id="insertion-sort">Insertion-sort</h3>](./insertion_sort.rs)

![alt text][insertion_image]

**Сортировка вставками** — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов. 

Обход массива начинается с начала. Считается, что первый элемент стоит на своем месте. Тогда берут следующий элемент, и передвигают его влево до тех пор, пока он не будет больше всех левостоящих элементов. Получается, что массив в левой части всегда будет отсортирован, а достигается это _вставкой_ элемента на подходящее место.

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n)
* Средняя скорость O(n^2)

__Memory__
* O(1)

* * *

[<h3 id="gnome-sort">Gnome-sort</h3>](./gnome_sort.rs)

![alt text][gnome_image]

**Гномья сортировка**, которую еще называют **глупой сортировкой** очень похожа на [сортировку вставками](#insertion-sort), только реализован он без вложенных циклов. 

Предоставлено два варианта алгоритма:
* _классический_, когда мы шагаем вправо до тех пор, пока текущий элемент не меньше элемента слева, в противном случае меняем их местами и делаем шаг назад. 
* _опитимизированный_, где оптимизация достигается введением новой переменной, которая будет запоминать позицию, начиная с которой мы начали уменьшать шаг. Тогда, когда мы перестанем идти влево, вместо бессмысленных проверок вправо, мы сразу перескочим на нужную позицию, которую еще не проверяли.

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n)
* Средняя скорость O(n^2)

__Memory__
* O(1)

* * *

[<h3 id="odd-even-sort">Odd-even</h3>](./odd_even_sort.rs)

![alt text][odd_even_image]

**Четно-нечетная сортировка** - относительно простой алгоритм сортировки, _разработанный для использования на параллельных процессорах_, является модификацией [пузырьковой сортировки](#bubble). Суть модификации в том, чтобы сравнивать элементы массива под чётными и нечётными индексами с последующими элементами независимо.

__Time complexity__
* Худшая скорость O(n^2)
* Лучшая скорость O(n)
* Средняя скорость O(n^2)

__Memory__
* O(1)

* * *

[<h3 id="merge-sort">Merge</h3>](./merge_sort.rs)

![alt text][merge_image]

**Сортировка слиянием** - довольно эффективный алгоритм сортировки, хороший пример использования принципа [разделяй и властвуй](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9_%D0%B8_%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)).

Заключается алгоритм в том, что он рекурсивно применяется к левой и правой частям массива, после чего эта цепочка продолжается, пока длина разбиения больше 1. Массив единичной длины считается отсортированным. Затем из них собираются массивы длины 2, оставляя их отсортированными простыми проверками. Из этих массивов собираются массивы все большего размера, сохраняя отсортированность, и так до тех пор, пока алгоритм не вернется к массиву исходного размера. Получается, что сначала сортируются короткие массивы, из них собираются отсортированные массивы большего размера и так далее, пока весь массив не будет отсортирован. 

Алгоритм выполняется за постоянное время, но в частности для массивов ему нужно выделять дополнительную память под копию данного массива.

__Time complexity__
* Худшая скорость O(n log n)
* Лучшая скорость O(n log n)
* Средняя скорость O(n log n)

__Memory__
* O(n)

<!--
ID
-->

[bubble_image]: https://upload.wikimedia.org/wikipedia/commons/0/06/Bubble-sort.gif "Bubble Sort"
[cocktail_shaker_image]: https://upload.wikimedia.org/wikipedia/commons/e/ef/Sorting_shaker_sort_anim.gif "Cocktail-Shaker Sort"
[comb_image]: https://upload.wikimedia.org/wikipedia/commons/4/46/Comb_sort_demo.gif "Comb Sort"
[counting_image]: https://c.tenor.com/zswbYsLbYqEAAAAd/counting-sort.gif "Counting Sort"
[insertion_image]: https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif "Insertion Sort"
[gnome_image]: https://upload.wikimedia.org/wikipedia/commons/8/89/Visualization_of_Gnome_sort.gif "Gnome Sort"
[odd_even_image]: https://upload.wikimedia.org/wikipedia/commons/1/1b/Odd_even_sort_animation.gif "Odd-even Sort"
[merge_image]: https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif "Merge Sort"